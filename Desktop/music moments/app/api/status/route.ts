import { NextRequest, NextResponse } from 'next/server'
import { getTaskManager } from '../../lib/task-manager'

// Zombie polling detection
const zombieTracker = new Map<string, { count: number, firstSeen: number }>()

// Enhanced logging utility
const logger = {
  info: (message: string, data?: any) => {
    console.log(`🎵 [STATUS] ${message}`, data ? JSON.stringify(data, null, 2) : '')
  },
  error: (message: string, error?: any) => {
    console.error(`❌ [STATUS] ${message}`, error?.message || error)
  },
  debug: (message: string, data?: any) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`🔍 [STATUS] ${message}`, data ? JSON.stringify(data, null, 2) : '')
    }
  },
  zombie: (message: string, data?: any) => {
    console.log(`🧟 [ZOMBIE-DETECTOR] ${message}`, data ? JSON.stringify(data, null, 2) : '')
  }
}

export async function GET(request: NextRequest) {
  const requestId = Math.random().toString(36).substr(2, 9)
  
  try {
    const { searchParams } = new URL(request.url)
    const songId = searchParams.get('songId')
    
    logger.info(`Status check requested`, { requestId, songId })
    
    if (!songId) {
      logger.error('Missing songId parameter', { requestId })
      return NextResponse.json(
        { 
          error: 'Song ID is required',
          requestId
        },
        { status: 400 }
      )
    }
    
    // Zombie polling detection for expired song IDs
    const now = Date.now()
    const zombieKey = `${songId}`
    
    if (!zombieTracker.has(zombieKey)) {
      zombieTracker.set(zombieKey, { count: 1, firstSeen: now })
    } else {
      const tracker = zombieTracker.get(zombieKey)!
      tracker.count++
      
      const timeSinceFirst = now - tracker.firstSeen
      const requestsPerMinute = (tracker.count / timeSinceFirst) * 60000
      
      // Detect zombie polling: >10 requests for non-existent task over >30 seconds
      if (tracker.count > 10 && timeSinceFirst > 30000) {
        logger.zombie('Zombie polling detected!', {
          songId,
          requestCount: tracker.count,
          timeSinceFirst: Math.round(timeSinceFirst / 1000) + 's',
          requestsPerMinute: Math.round(requestsPerMinute)
        })
        
        // Return kill signal to frontend
        return NextResponse.json({
          status: 'zombie_detected',
          error: 'Zombie polling detected - killing runaway intervals',
          killSignal: true,
          pollingStats: {
            requestCount: tracker.count,
            duration: Math.round(timeSinceFirst / 1000),
            requestsPerMinute: Math.round(requestsPerMinute)
          },
          requestId
        }, { status: 410 }) // 410 Gone - resource no longer available
      }
    }
    
    // Clean up old zombie trackers (older than 10 minutes)
    for (const [key, value] of zombieTracker.entries()) {
      if (now - value.firstSeen > 600000) { // 10 minutes
        zombieTracker.delete(key)
      }
    }
    
    // Check ElevenLabs tasks in task manager
    const taskManager = getTaskManager()
    const task = taskManager.getTask(songId)
    
    logger.debug('Task lookup result', { 
      requestId, 
      songId, 
      found: !!task,
      taskKeys: taskManager.getAllTaskIds(),
      totalTasks: taskManager.getTaskCount()
    })
    
    if (task) {
      // Task found in storage
      logger.info('Found task in storage', { 
        requestId,
        songId,
        status: task.status,
        hasAudioData: !!task.audioData
      })
      
      return NextResponse.json({
        status: task.status || 'processing',
        audioUrl: task.audioUrl || null,
        audioData: task.audioData || null,
        coverUrl: null, // ElevenLabs doesn't provide cover images
        lyrics: task.text || task.lyrics,
        voiceId: task.voiceId,
        voiceCategory: task.voiceCategory,
        voiceName: task.voiceName,
        provider: 'elevenlabs',
        title: 'Your Personal Song',
        artist: 'ElevenLabs AI Music',
        attribution: 'Generated by ElevenLabs AI Music',
        requestId
      })
    }
    
    // Check if this is a demo song
    if (songId.startsWith('demo-song-')) {
      logger.info('Demo mode - returning mock completed song', { requestId, songId })
      return NextResponse.json({
        status: 'complete',
        audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3',
        coverUrl: 'https://picsum.photos/400/400?random=' + songId.slice(-4),
        lyrics: `[Verse 1]\nThis is a demo song created for testing\nWhen the real API key isn't working\nBut the app still needs to show its features\nSo here's a placeholder melody\n\n[Chorus]\nDemo mode, demo mode\nJust for testing, don't you know\nGet a real API key\nTo make the music flow\n\n[Verse 2]\nYour story was touching and true\nBut this is just a sample for you\nOnce the API is connected right\nYour real song will shine so bright`,
        isDemoMode: true,
        requestId
      })
    }
    
    // Task not found
    logger.error('Task not found', { 
      requestId, 
      songId,
      availableTasks: taskManager.getAllTaskIds()
    })
    return NextResponse.json(
      { 
        error: 'Task not found',
        songId,
        requestId
      },
      { status: 404 }
    )
    
  } catch (error: any) {
    logger.error('Status check failed', { 
      requestId,
      error: error.message,
      stack: error.stack
    })
    
    return NextResponse.json(
      { 
        error: 'Failed to check status',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined,
        requestId
      },
      { status: 500 }
    )
  }
}
